# PFXFlow Specification v0.10.7 - Implementation Readiness Review

## Executive Summary

**Verdict: READY TO IMPLEMENT** with caveats

**Overall Spec Quality: 8.5/10** - Major improvement from v0.9.9

The specification is now comprehensive enough to begin PFXCore implementation. Most critical ambiguities have been resolved through detailed schemas, examples, and explicit contracts. A few minor gaps remain, but these can be addressed with documented assumptions or deferred to later phases.

---

## Major Improvements from v0.9.9

### ✅ Resolved Ambiguities

1. **Design and Technology Specification** (NEW: Sections 3.8, 3.9)
   - Complete `design.toml` schema with all required/optional fields
   - Complete `tech.toml` schema with collateral mapping
   - Clear separation of concerns: PFXStudy populates, PFXCore exports
   - Path semantics explicitly defined as run-relative
   - **Resolution**: PFXCore validates existence of `inputs/design/` and `inputs/tech/` but does NOT create or populate them

2. **Variable Export Model** (MAJOR REWRITE: Section 3.12)
   - Comprehensive flattening rules for TOML→Tcl
   - Clear namespace prefixing (`run.*`, `pipeline.*`, `design.*`, `tech.*`)
   - Array export semantics defined
   - Stage variable mapping explicitly defined (`pipeline.stage.<name>.*`)
   - Reserved variables enumerated (`pfx(run.dir)`, `pfx(stage.dir)`, etc.)
   - **Resolution**: Export ALL eligible variables from all TOML files with explicit flattening rules

3. **Pipeline Schema** (COMPREHENSIVE: Section 3.7.2)
   - Complete field-by-field specification
   - `depends_on` vs `order` semantics clarified
   - `inputs` and `outputs` arrays for stage I/O contracts
   - Path resolution rules crystal clear
   - Example pipeline with realistic tool invocations
   - **Resolution**: `order` is for naming, `depends_on` is for execution graph

4. **Status.json Schema** (DETAILED: Section 3.16)
   - Complete JSON structure with all required fields
   - Success criteria: `exit_code == 0` AND all `declared_outputs` exist
   - State machine: not_started → running → complete/failed
   - Timestamp format specified (RFC 3339 with UTC offset)
   - I/O tracking with `outputs_present` and `outputs_missing`
   - **Resolution**: Completion rule is explicit and verifiable

5. **Failure Policy** (EXPLICIT: Section 3.7.2.7)
   - "If a stage does not complete successfully, PFXCore SHALL stop pipeline execution immediately"
   - **Resolution**: Fail-fast is the only supported mode in v1

6. **Force Flag Semantics** (CLEAR: Sections 3.3.1, 3.14.2)
   - `--force` restarts execution, ignoring existing output and overwriting files
   - `stage_launch.sh` regenerated only with `--force`
   - **Resolution**: Force means "start from scratch, regenerate everything"

7. **Working Directory Policy** (UNAMBIGUOUS: Section 3.5.1)
   - "stage directory" IS "current working directory"
   - Tool execution happens in `stages/<NN>_<stage>/`
   - All TOML paths are run-relative, resolved via `pfx(run.dir)`
   - **Resolution**: No ambiguity remains

8. **Template System** (RESOLVED: Section 3.4.2)
   - "PFXCore never parses templates; it consumes only resolved TOML"
   - Templates are 100% PFXStudy concern
   - **Resolution**: Out of scope for PFXCore implementation

---

## Remaining Gaps (Minor)

### 1. env.sh Contents (Low Impact)

**Status**: Referenced but not specified

**What We Know**:
- Generated by PFXStudy
- Located at `<run_dir>/env.sh`
- Sourced by `stage_launch.sh` before tool invocation
- Must exist before PFXCore execution

**What We Don't Know**:
- What environment variables it exports
- What it sources (tool setup scripts, licenses?)
- Whether it's study-wide or run-specific

**Mitigation Strategy**:
- Treat as opaque: just verify existence and source it
- Document assumption: "PFXCore treats env.sh as a black box"
- No validation of contents needed
- Example for testing: minimal stub that exports PATH

**Impact**: Very Low - PFXCore just needs to source it

### 2. Harvesting Framework (Acknowledged Gap)

**Status**: Component listed, not specified

**From Spec**:
- Listed in Section 3.3: "PFXCore Components" includes harvester
- Section 1.2: "optionally harvests individual runs"

**Mitigation Strategy**:
- Defer to Phase 2
- Harvesting is just another stage in the pipeline (e.g., `order=99`)
- Can be implemented via normal stage execution
- No special PFXCore support needed in v1

**Impact**: None - harvesting = regular pipeline stage

### 3. Dependency Graph Validation (Clarification Needed)

**Question**: How to resolve conflicts between `order` and `depends_on`?

**Example Conflict**:
```toml
[[stage]]
name = "synth"
order = 10
depends_on = ["init"]  # init doesn't exist yet!

[[stage]]
name = "init"
order = 20
depends_on = []
```

**From Spec** (Section 3.7.2.4):
- "A conflict between `order` and `depends_on` is a fatal error"

**Clarification Needed**:
- What constitutes a conflict?
- Is `order` purely cosmetic (directory naming)?
- Must `depends_on` dependencies have lower `order` values?

**Mitigation Strategy**:
- **Conservative Interpretation**: Dependency order must be consistent with `order` values
- Validation rule: For all edges in dependency graph, `order(src) < order(dst)`
- Document this as PFXCore v1 policy
- Ask for clarification if this is too restrictive

**Impact**: Low - Most real pipelines will naturally satisfy this

---

## What's Still Missing (But Doesn't Block Implementation)

### Optional Features (Can Defer)
1. **Hooks** - Mentioned but unspecified, defer to Phase 2
2. **Schema Migration** - Section 3.11 says "fail the run" for old schemas
3. **Slurm Integration** - Explicitly marked as placeholder
4. **Multiple Schema Versions** - Only v1 defined

### Nice-to-Have Examples (Not Blockers)
1. **Complete Run Directory Tree** - Would help testing
2. **Example env.sh** - Easy to stub for testing
3. **Real-world Design/Tech Files** - Not needed for unit tests

---

## Implementation Readiness Assessment

### Phase 1: Core Data Structures (READY)
**Confidence: 95%**

Can implement immediately:
- `Run` class: Load and parse `run.toml`, `design.toml`, `tech.toml`
- `Pipeline` class: Load and parse `pipeline.toml` with full schema
- `Stage` class: Represent individual stage configuration
- `StageStatus` class: Read/write `status.json` with complete schema
- TOML parsing with toml11
- Variable validator with exact character set rules

**No blockers**: All schemas are complete

### Phase 2: Validation (READY)
**Confidence: 90%**

Can implement immediately:
- Schema validation for all TOML files
- Key character set validation (Section 3.12.6: `[A-Za-z0-9._-]+`)
- Value restriction validation (Section 3.12.2: no `$`, quotes, newlines, backslashes)
- Pipeline ordering and dependency graph validation
- Required field checks
- Unique name checks

**Minor gap**: Dependency vs order conflict semantics (mitigation documented above)

### Phase 3: Materialization (READY)
**Confidence: 85%**

Can implement immediately:
- Create stage directory structure
- Generate `stage_launch.sh` with exact contract (Section 3.14.1)
- Generate `pfx_vars.tcl` with complete export rules (Section 3.12)
- Initialize `status.json` files
- Verify `env.sh` and `scripts/` exist

**No significant blockers**: All contracts are specified

### Phase 4: Execution (READY)
**Confidence: 80%**

Can implement immediately:
- Stage execution orchestration
- Dependency checking via `depends_on`
- Exit code capture
- Output validation (check `declared_outputs` exist)
- Status.json updates (start_time, end_time, exit_code, outputs_present)
- Fail-fast on stage failure

**Minor gaps**:
- env.sh contents unknown (mitigation: treat as opaque)
- Tool behavior is external (not PFXCore's concern)

### Phase 5: Variable Export (READY)
**Confidence: 95%**

Can implement immediately:
- TOML table flattening with dot-separated keys
- Namespace prefixing (run/pipeline/design/tech)
- Array export as Tcl lists
- Stage variable mapping (`pipeline.stage.<name>.*`)
- Reserved variable injection
- Canonical Tcl emission format

**No blockers**: Section 3.12 is extremely detailed

---

## Critical Implementation Questions

### Q1: Directory Creation Responsibility

**Question**: Does PFXCore create `inputs/design/` and `inputs/tech/`?

**Answer from Spec**:
- Section 4.3: "PFXCore SHALL only require that `inputs/design/` and `inputs/tech/` exist"
- Section 3.8.1: "PFXStudy is responsible for populating it"
- Section 3.9.1: "PFXStudy is responsible for populating the bundle"

**Decision**: PFXCore validates existence, does NOT create or populate

### Q2: Stage Script Location

**Question**: Where are stage scripts (synth.tcl, init.tcl) stored?

**Answer from Spec**:
- Section 3.5: `scripts/` directory in run layout
- Section 3.7.2.6: "Relative paths inside `exec.argv` are resolved from the stage directory"
- Example: `["genus", "-batch", "-files", "../../scripts/synth.tcl"]`

**Decision**: Scripts are in `<run_dir>/scripts/`, referenced as `../../scripts/` from stage directory

### Q3: Output Validation Timing

**Question**: When are `declared_outputs` checked?

**Answer from Spec**:
- Section 3.7.2.7: "Validate declared outputs" after stage execution
- Section 3.16.4: "`declared_outputs` files all exists" is part of success criteria

**Decision**: Check after tool exit, before marking stage complete

---

## Recommended Implementation Strategy

### Week 1: Core Parsing
1. Implement TOML parsing infrastructure
2. Build `Run`, `Pipeline`, `Stage` classes
3. Schema validation
4. Unit tests with example files

### Week 2: Variable Export
1. Implement table flattening
2. Implement namespace prefixing
3. Generate `pfx_vars.tcl`
4. Comprehensive export tests

### Week 3: Materialization
1. Directory structure creation
2. `stage_launch.sh` generation
3. `status.json` initialization
4. Integration tests

### Week 4: Execution
1. Stage orchestration
2. Dependency resolution
3. Status tracking
4. Output validation
5. End-to-end tests

---

## Test Artifacts Needed

### Minimal Set (Can Create Ourselves)
1. **run.toml** - Use example from Section 3.15.12
2. **pipeline.toml** - Use example from Section 3.7.3
3. **design.toml** - Use example from Section 3.8.8
4. **tech.toml** - Use example from Section 3.9.8
5. **env.sh** - Create minimal stub:
   ```bash
   #!/bin/bash
   # Minimal env.sh stub for testing
   export PATH=/usr/bin:/bin
   ```

### Recommended Test Structure
```
test/fixtures/
  minimal_run/
    run.toml
    design.toml
    tech.toml
    pipeline.toml
    env.sh
    inputs/
      design/
      tech/
    scripts/
      synth.tcl
      init.tcl
```

---

## Risks and Mitigations

### Risk 1: Tool Execution Environment
**Risk**: env.sh might contain critical setup we don't understand

**Mitigation**:
- Treat env.sh as black box in v1
- Document assumption clearly
- Create stub for unit tests
- Real env.sh is PFXStudy's responsibility

**Likelihood**: Low
**Impact**: Low

### Risk 2: Real Tool Behavior
**Risk**: Actual EDA tools (genus, innovus) might have unexpected behavior

**Mitigation**:
- PFXCore only cares about exit codes and output files
- Tool semantics are out of scope
- Use mock tools for unit tests
- Integration tests with real tools come later

**Likelihood**: Medium
**Impact**: Low (out of scope)

### Risk 3: Dependency Graph Complexity
**Risk**: Complex dependency graphs might expose ordering edge cases

**Mitigation**:
- Start with linear pipelines (synth→init→place→route)
- Add DAG support incrementally
- Document order/depends_on policy clearly
- Validate at parse time

**Likelihood**: Low
**Impact**: Medium

---

## Final Recommendation

### ✅ PROCEED WITH IMPLEMENTATION

**Rationale**:
1. All critical ambiguities from v0.9.9 are resolved
2. Complete schemas for all data structures
3. Execution semantics are explicit
4. Variable export rules are comprehensive
5. Example files provide concrete reference
6. Remaining gaps are minor and have clear mitigations

**Starting Point**:
1. Begin with Phase 1 (Core Parsing)
2. Use provided examples as test fixtures
3. Create minimal env.sh stub
4. Document all assumptions
5. Build incrementally with unit tests at each layer

**Confidence Level**: 85%

The spec is not perfect, but it's good enough to produce a working v1 implementation. Any remaining ambiguities can be resolved through clarifying questions during development, and the architecture I proposed earlier maps directly onto this specification.

---

## Comparison: v0.9.9 → v0.10.7

| Aspect | v0.9.9 | v0.10.7 | Improvement |
|--------|--------|---------|-------------|
| Design/Tech Spec | Missing | Complete | ⭐⭐⭐⭐⭐ |
| Variable Export | Vague | Detailed | ⭐⭐⭐⭐⭐ |
| Pipeline Schema | Partial | Complete | ⭐⭐⭐⭐ |
| Status.json | Basic | Comprehensive | ⭐⭐⭐⭐ |
| Failure Policy | Unclear | Explicit | ⭐⭐⭐⭐ |
| Path Semantics | Confusing | Clear | ⭐⭐⭐⭐ |
| Examples | Few | Many | ⭐⭐⭐⭐ |
| env.sh | Opaque | Still Opaque | ⭐ |
| Overall | 7.5/10 | 8.5/10 | +1.0 |

---

## Questions for Paul Before Starting

### Priority 1 (Would Help)
1. Should dependency `depends_on` edges respect `order` values?
   - My assumption: Yes, validate that dependency order is consistent with `order`

2. Confirm env.sh is truly opaque for v1?
   - My assumption: Yes, just verify existence and source it

### Priority 2 (Nice to Have)
3. Any preference on TOML parsing library?
   - My recommendation: toml11 (header-only, modern C++)

4. Any special logging requirements?
   - My assumption: Simple console logging to start, structured logging later

### Priority 3 (Can Defer)
5. Should we support `--continue-on-error` in v2?
   - Current spec: fail-fast only

6. Hook execution timing?
   - Current spec: listed as component, no details

---

## Bottom Line

**We're ready to generate code.** The specification is comprehensive, well-structured, and provides sufficient detail for implementation. The few remaining gaps are minor and easily mitigated with documented assumptions.

Your work on v0.10.7 resolved all the blockers I identified in v0.9.9. The design/tech specs, variable export model, and pipeline schema are particularly well done.

Let's build PFXCore.
